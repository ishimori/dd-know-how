# 実例: バグ修正DD（見落としチェック記録付き）

ハードコード値に起因するバグを修正したDDの実例です（匿名化済み）。
**見落としチェック**で実際に問題を発見した記録を含みます。

---

# DD-081: 計算ロジックのハードコード値修正

| 作成日 | 更新日 | ステータス |
| ------ | ------ | ---------- |
| 2026-02-05 | 2026-02-06 | 完了     |

## 目的

`calculator.js` が特定タイプの計算で基準値（100単位あたり156）をハードコードしている問題を修正する。

## 背景・課題

ドキュメント更新時にバグを発見。

### 現状のバグ

`calculator.js` L459:
```javascript
const unitValue = Math.round(156 * item.amount / 100);
```

全タイプで 156（タイプAの基準値）をハードコードしており、タイプB・Cでは正しい値と大きく乖離する。

| タイプ | コード | 実際の値/100 | 使用値 | 誤差 |
|--------|--------|-------------|--------|------|
| タイプA | A001 | 156 | 156 | 正しい |
| タイプB | B001 | 347 | 156 | **-55%** |
| タイプC | C001 | 333 | 156 | **-53%** |

### 影響箇所

1. **L459**: `unitValue` 計算（156ハードコード）
2. **L706-708**: 出力内の計算例（156, 37.1をハードコード）
3. **L777**: 注記テキスト（タイプA前提の記述）
4. **L782**: 目標値計算（156ハードコード）

### 関連バグ（同時修正検討）

- **validator.js**: タイプBのコードリストに誤ったコード（X001）が含まれている
- **checker.js**: タイプCの目安値が異なる単位で定義されている

### スコープ外（別DD起票）

- **タイプDのコード不整合**: マスタデータ自体の誤りであり、本DDの範囲外
- **表示用文字列の整合性**: 計算には無影響だが整合性上の課題

## 検討内容

### 方針案

`itemInfo` にタイプ別の基準値情報を持たせ、ハードコード値を置き換える。
マスタデータから該当コードの値を参照するか、タイプ別の定数マップを作成する。

## 決定事項

タイプ別定数マップ（`TYPE_VALUES`）を作成し、動的に参照する方式を採用。

## タスク一覧

### Phase 0: 事前精査
- [x] 📋 **影響範囲の詳細確認**（calculator.js, checker.js, validator.js）
- [x] 📋 **テストケースの確認**（既存テストがこの値に依存しているか）
- [x] 📋 **修正前ベースラインの記録**

### Phase 1: calculator.js 修正
- [x] タイプ別の基準値マップ作成
- [x] L459のハードコード値を動的参照に変更
- [x] L706-708の計算例をタイプ別で切り替え
- [x] L777の注記テキストをタイプ別で切り替え
- [x] L782の目標値計算を修正
- [x] 🔍 **見落としチェック（最低1件発見）**

### Phase 2: 関連バグ修正
- [x] checker.js: 目安値の単位統一
- [x] validator.js: タイプBコードから X001 を除外
- [x] calculator.js: `getTypeValue` / `TYPE_VALUES` をexport（テスト用）
- [x] 🔍 **見落としチェック（最低1件発見）**

### Phase 3: テスト・検証
- [x] タイプ別の出力検証テスト追加（A→156, B→347, C→333）
- [x] 既存テストの更新・実行
- [x] 修正後の動作確認
- [x] 仕様書の更新
- [x] 🔍 **見落としチェック（最低1件発見）**

## ログ

### 2026-02-06 PH0完了

#### 影響範囲の詳細確認

**calculator.js（6箇所）:**

| 行 | コード | バグ内容 |
|----|--------|----------|
| L459 | `unitValue = Math.round(156 * item.amount / 100)` | 全タイプで156ハードコード |
| L706-708 | 計算例 `156 ×`, `37.1 ×` | タイプB(347)・C(333)では誤った計算例 |
| L777 | 注記テキスト | タイプA前提の記述 |
| L782 | 目標値計算 | ハードコード値で誤計算 |

**checker.js（単位不整合）:**
- タイプCの目安値が異なる単位で定義されている

**validator.js（コード誤り）:**
- `TYPE_CODES.typeB = ['B001', 'B002', 'X001']`
- X001 はタイプBではない → 除外必要

#### テスト依存の確認

| テストファイル | 156/37.1依存 | 影響 |
|---------------|-------------|------|
| calculator.test.js | なし | コード・名前・量のみ確認 |
| checker.test.js | なし | タイプAのみテスト。タイプB/Cテスト追加が必要 |

### 2026-02-05
- DD作成（ドキュメント更新時にバグ発見）

---

## 見落としチェック記録

### Phase 1 見落としチェック

**変更ファイル:** calculator.js（1ファイル = 小規模）

**発見結果:**

| # | 発見した問題/改善点 | 重要度 | 対応 |
|---|-------------------|--------|------|
| 1 | L760のcalculation_basisも同じハードコードがあった | 高 | ✅ 修正済 |

**残存ハードコード確認:**
- `156`: マップ内のタイプAデータのみ → 正しい
- `37.1`: マップ内のタイプAデータのみ → 正しい

**リスク:** なし。既存のタイプA選択時は従来と同一の値が使用される。

### Phase 2 見落としチェック

**変更ファイル:** checker.js, validator.js, calculator.js（3ファイル = 中規模）

**発見結果:**

| # | 発見した問題/改善点 | 重要度 | 対応 |
|---|-------------------|--------|------|
| 1 | calculator.jsのL340にもタイプB判定コードがあり、X001が含まれていた | 高 | ✅ 修正済 |
| 2 | JSDoc型定義に `typeC` が未追加だった | 中 | ✅ 追加済 |

**リスク:** checker.jsの目安値が大幅に変わるため、既存のチェック結果が変わる。ただし旧値は常に不足判定だったため、修正後の方が正しい動作。

### Phase 3 見落としチェック

**変更ファイル:** calculator.test.js, checker.test.js, 仕様書（3ファイル = 中規模）

**発見結果:**

| # | 発見した問題/改善点 | 重要度 | 対応 |
|---|-------------------|--------|------|
| 1 | checker.test.jsにタイプB/タイプCのテストがなかった | 高 | ✅ 追加済 |
| 2 | export漏れで新関数がテストできなかった | 中 | ✅ 修正済 |

**テスト結果:**
- 新規テスト: 16件追加、全件パス
- 既存テスト: 179件パス

**仕様書更新:**
- 計算ロジック仕様書に以下を追記:
  - `getTypeValue(code)` 関数の説明
  - タイプ別基準値マップのテーブル

**残存課題（別DD）:**
- DD-082: タイプDのコード不整合調査
- DD-085: 表示用文字列の整合性

---

## この実例のポイント

### 1. 見落としチェックの実践

各Phaseで **最低1件以上** の発見を記録。形式的な「問題なし」ではなく、具体的な問題を探して記録している。

### 2. 発見から修正への流れ

| Phase | 発見した問題 | 対応 |
|-------|------------|------|
| Phase 1 | calculation_basisにも同じハードコード | 即時修正 |
| Phase 2 | 別ファイルにも同じコードが含まれていた | 即時修正 |
| Phase 3 | テストがなかった → テスト追加 | 即時対応 |

### 3. スコープ外の明確化

本DDで対応すべき範囲と、別DDで対応すべき範囲を明確に分離。「残存課題（別DD）」として記録。

### 4. 変更規模に応じた発見数

- Phase 1（小規模）: 1件発見
- Phase 2（中規模）: 2件発見
- Phase 3（中規模）: 2件発見

「発見ゼロは疑わしい」の原則に基づき、各Phaseで必ず問題を探している。
