# 機能開発フロー（9ステップ）

新機能の実装は、必ず以下のフローに従う。**いきなりコードを書かない。**

```
┌─────────────────────────────────────────────────────────────┐
│  Step 1: DD作成          「〇〇機能を作りたい」              │
│  Step 2: 仕様確認        ユーザー承認を得る                  │
│  Step 3: 実装前チェック  仕様書・既存コードを確認             │
│  Step 4: コーディング    規約に従って実装                    │
│  Step 5: テスト作成      必要に応じてテスト作成               │
│  Step 6: コード検証      Lint + セルフチェック + 動作確認     │
│  Step 7: レビュー        コードレビュー                      │
│  Step 8: 仕様書同期      DDの変更を doc/spec に反映 + コンテキスト回収 │
│  Step 9: コミット        git commit → /dd archive            │
└─────────────────────────────────────────────────────────────┘
```

---

## 進捗表示ルール（推奨）

**各ステップ開始時に、以下のフォーマットで進捗を表示する。**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📍 Step N/9: ステップ名
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 1. DD作成       ✅ 2. 仕様確認     ✅ 3. 実装前チェック
▶️ 4. コーディング  ⬜ 5. テスト作成   ⬜ 6. コード検証
⬜ 7. レビュー      ⬜ 8. 仕様書同期   ⬜ 9. コミット
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 記号の意味

| 記号 | 意味 |
|------|------|
| ✅ | 完了済み |
| ▶️ | 現在実行中 |
| ⬜ | 未実行 |

### 現在地の確認

いつでも `/dd status` で現在のステップを確認できる。

---

## Step 1: DD作成

**目的**: 何を作るかを明確にし、意思決定を記録する

```bash
/dd new 機能名
```

DDに以下を記載する：
- **目的**: 何を作るか（機能概要）
- **背景・課題**: なぜ必要か
- **タスク一覧**: 実行するタスク

---

## Step 2: 仕様確認（ユーザー承認）

**目的**: 認識齟齬を防ぐため、日本語で仕様を確認する

以下を説明し、ユーザーの「OK」を得てから次へ進む：
- 何を作るか（機能概要）
- どう作るか（技術的アプローチ）
- 影響範囲（既存コードへの影響）

---

## Step 3: 実装前チェック

**目的**: 仕様書・既存コードを確認し、漏れを防ぐ

### チェック内容

| No | チェック項目 | 参照先 |
|----|-------------|--------|
| 1 | 仕様書の確認 | `doc/spec/` 配下の関連ファイル |
| 2 | 画面仕様の確認 | `doc/spec/03_画面仕様/` |
| 3 | テーブル定義の確認 | `doc/spec/04_テーブル定義.md` |
| 4 | 既存コードの確認 | 関連するソースファイル |
| 5 | 設計書に漏れがないか | 仕様書 vs 既存コード の差分 |

### 記録方法

チェック結果はDDの「実装前チェック」セクションに記録：

```markdown
## 実装前チェック

### チェック実施日: YYYY-MM-DD

#### 1. 仕様書確認
- 参照ファイル: ...
- 確認結果: ...

#### 2. 既存コード確認
- 参照ファイル: ...
- 確認結果: ...

#### 3. 設計書との差分
- 漏れている仕様: ...
- 追加で必要な対応: ...
```

---

## Step 4: コーディング

**目的**: 規約に従ってコードを実装する

### 主要ルール（参考）

- コーディング規約に従う
- レイヤー構成を守る（views → services → repositories → models など）
- 適切なエラーハンドリング

---

## Step 5: テスト作成

**目的**: 重要機能の品質を担保する

### テストが必要な機能例

| 優先度 | 機能 | 理由 |
|--------|------|------|
| **必須** | 認証・ログイン | セキュリティに直結 |
| **必須** | 重要なビジネスロジック | データ整合性に影響 |
| **必須** | 権限チェック | 不正アクセス防止 |
| **高** | 金額計算 | 業務に直接影響 |

### DDへのテストシナリオ記載

テストが必要な機能では、DDに以下を記載：

```markdown
## テストシナリオ

### 正常系
- [ ] <操作>が正常に完了すること

### 異常系
- [ ] <条件>の場合、エラーメッセージが表示されること

### 権限
- [ ] 管理者のみ<操作>が可能であること
```

---

## Step 6: コード検証

**目的**: 規約違反・動作不良を検出する

### 6-1. 自動チェック（Lint）

プロジェクトで使用しているLintツールを実行

### 6-2. セルフチェック

コーディング規約に沿っているか確認

### 6-3. 動作確認

実際にアプリケーションを起動して動作確認

---

## Step 7: レビュー

**目的**: 最終確認を行う

- セルフレビュー
- 必要に応じてチームメンバーによるレビュー

---

## DA批判レビュー（Devil's Advocate視点）

**「確認したか？」ではなく「どこが壊れるか？」を問う。**

LLMは楽観バイアスで「問題なし」と言いがち。以下のDA手順で批判的視点を強制する:

1. **壊れる前提で探す**: 「完了した」ではなく「このPhaseの変更で何が壊れるか」と問う
2. **暗黙の前提を疑う**: 「今動いている」ではなく「前提が崩れるケースは？」と深掘りする
3. **将来の破壊を予測する**: 「今は問題ない」ではなく「半年後の変更で壊れないか？」と問う
4. **発見を記録**: 見つけた問題を必ず記録（何も見つからないのは疑わしい）

**DA観点チェックリスト（毎回確認）:**
- 矛盾・不整合はないか
- 暗黙の前提条件が崩れるケースはないか
- エッジケース・境界条件の漏れはないか
- 「正常系しか考えていない」箇所はないか
- 依存関係の見落としはないか
- 将来の変更で壊れやすい設計はないか

### 最低発見数ルール

| 変更規模 | 最低発見数 |
|---------|-----------|
| 小（1-2ファイル） | 1件以上 |
| 中（3-5ファイル） | 2件以上 |
| 大（6ファイル以上） | 3件以上 |

### 🔄 再チェック発動条件（どちらかを満たせば発動）

#### 条件A: 中レベル以上の発見がある場合（CRITICAL）

**重要度「中」または「高」が1件以上 → 🔄 別角度で再チェック必須**

- 中レベル以上 ＝ 設計判断の甘さや構造的な問題を示唆
- 同種の問題がまだ潜んでいる可能性が高い
- 「1件見つかったなら、似た問題がもう1件あるはず」の姿勢で探す

#### 条件B: 多数発見の場合

| 変更規模 | 発見数 | 追加アクション |
|---------|--------|--------------|
| 小（1-2ファイル） | 3件以上 | 🔄 別角度で再チェック必須 |
| 中（3-5ファイル） | 5件以上 | 🔄 別角度で再チェック必須 |
| 大（6ファイル以上） | 7件以上 | 🔄 別角度で再チェック必須 |

**🔄 別角度での再チェック方法:**
1. **視点を変える**: 実装者視点 → レビュアー視点 → ユーザー視点 → 将来の保守者視点
2. **チェック観点を変える**:
   - 1回目: 機能・ロジックの正しさ
   - 2回目: テストカバレッジ・境界値
   - 3回目: ドキュメント・仕様書との整合性
3. **関連ファイルを広げる**: 直接変更したファイル → importしているファイル → 同じディレクトリの関連ファイル

### よくある見落としパターン

| パターン | 例 |
|---------|-----|
| テスト漏れ | 新規関数を追加したがテストを書いていない |
| 呼び出し元未確認 | 関数の戻り値を変更したが呼び出し元を確認していない |
| 定数マップ不完全 | 6種類あるはずが5種類しかマップに登録していない |
| 仕様書未更新 | コードは直したが仕様書に反映していない |
| export漏れ | 新関数を追加したがexportしていない（テスト不可） |

---

## Step 8: 仕様書同期 + コンテキスト回収（DD完了時）

**目的**: DDで決定した内容を `doc/spec/` の仕様書に反映し、会話コンテキストの知見をDD本体に書き戻す

### タイミング
- DDの全タスクが完了し、アーカイブする直前

### 実行方法
`/dd archive DD-XXX` 実行時に自動でチェックされる。

### チェック内容

以下を確認し、同期が必要な項目をリストアップする：

| 変更種別 | 関連仕様書 |
|----------|-----------|
| 画面の追加・変更 | `doc/spec/03_画面仕様/` |
| テーブル・カラムの追加・変更 | `doc/spec/04_テーブル定義.md` |
| 機能の追加・変更 | `doc/spec/02_機能一覧.md` |

### 出力フォーマット

```markdown
## 仕様書同期チェック

このDDで以下の仕様変更がありました：

| 変更内容 | 関連仕様書 | 反映状況 |
|----------|-----------|----------|
| ログイン画面を追加 | 03_画面仕様/login.md | ✅ 反映済 |
| usersテーブルにカラム追加 | 04_テーブル定義.md | ⚠️ 要確認 |

### 対応
- ✅ 反映済: そのままアーカイブ可
- ⚠️ 要確認: 仕様書を更新してからアーカイブ
```

### コンテキスト回収

会話コンテキストにのみ蓄積された知見（gotcha・回避策・制約）をDD本体に書き戻し、AI記憶を整理する。

> 確認項目・判断基準の詳細は `.claude/skills/workflow/SKILL.md`「コンテキスト回収」を参照

---

## Step 9: コミット → DDアーカイブ

**目的**: 変更を記録し、DDを完了状態にする

### コミット
```bash
git add . && git commit -m "機能名: 概要"
```

### DDアーカイブ
```bash
/dd archive DD-XXX
```

仕様書同期が完了していれば、DDは `doc/archived/DD/` に移動される。

---

## フロー例外（省略できるケース）

以下の場合はDDを省略可能：
- 単純なバグ修正（原因が明確）
- ドキュメントの誤字修正
- 既存DDのタスク消化

---

## クイックリファレンス

| ステップ | コマンド/参照 |
|----------|--------------|
| DD作成 | `/dd new タイトル` |
| DD参照 | `/dd {番号}` |
| DD一覧 | `/dd list` |
| ステータス確認 | `/dd status` |
| DDアーカイブ | `/dd archive {番号}` |
| コミット | `git commit` |
