---
name: workflow
description: 9ステップ開発フロー・Phase管理・DA批判レビュー・GEM分析（オプショナル）
---

# 開発ワークフロー

DDを使った開発作業のフロー管理スキルです。
**このスキルはオプショナル**です。必要に応じて呼び出してください。

## 呼び出し例

- 「9ステップで進めて」「ワークフローに従って」
- 「Phase 1を始めて」「次のPhaseへ」
- 「DA批判レビューして」「Phase完了」
- 「現在のステータスは？」

---

## 9ステップ開発フロー

```
Step 1: DD作成          「〇〇機能を作りたい」
Step 2: 仕様確認        ユーザー承認を得る
Step 3: 実装前チェック  仕様書・既存コードを確認
Step 4: コーディング    規約に従って実装
Step 5: テスト作成      必要に応じてテスト作成
Step 6: コード検証      Lint + セルフチェック
Step 7: レビュー        コードレビュー
     ★ GEM分析          独立批判レビュー（Gemini API or 別コンテキストDA）
Step 8: 仕様書同期      DDの変更を doc/spec に反映 + コンテキスト回収
Step 9: コミット        git commit → /dd archive
```

### 進捗表示フォーマット

各ステップ開始時に表示：

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📍 Step N/9: ステップ名
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 1. DD作成       ✅ 2. 仕様確認     ✅ 3. 実装前チェック
▶️ 4. コーディング  ⬜ 5. テスト作成   ⬜ 6. コード検証
⬜ 7. レビュー      ⬜ 8. 仕様書同期   ⬜ 9. コミット
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 対象DD: DD-XXX_機能名
```

---

## Phase 0: 事前精査（CRITICAL）

**DD作成後、実装前に必ず実施。**

### 目的

タスクが粗い粒度で書かれていることがある。実装前に精査：

1. **タスクの詳細化**: 曖昧なタスクがないか
2. **タスクの分解**: 大きすぎるタスクは2〜3個に
3. **不足タスクの追加**: 動作確認・ドキュメント更新など

### チェックリスト

| 項目 | 観点 |
|------|------|
| タスク粒度 | 1〜2時間で完了する粒度か |
| 具体性 | 何をすればよいか明確か |
| 順序 | 依存関係は明確か |
| 網羅性 | 必要なタスクがすべてあるか |

### 記録

```markdown
### YYYY-MM-DD
- Phase 0 完了
  - Phase 1: タスクを3個に分解
  - Phase 2: ファイル名を追記
```

---

## Phase完了時のDA批判レビュー（CRITICAL）

**各Phaseを完了とする前に必ず実行。**

### ⚠️ 重要: DA批判レビュー（Devil's Advocate視点）

**「確認したか？」ではなく「どこが壊れるか？」を問う。**

LLMは楽観バイアスで「問題なし」と言いがち。以下のDA手順で批判的視点を強制する:

1. **壊れる前提で探す**: 「完了した」ではなく「このPhaseの変更で何が壊れるか」と問う
2. **暗黙の前提を疑う**: 「今動いている」ではなく「前提が崩れるケースは？」と深掘りする
3. **将来の破壊を予測する**: 「今は問題ない」ではなく「半年後の変更で壊れないか？」と問う
4. **発見を記録**: 見つけた問題を必ず記録（何も見つからないのは疑わしい）

**DA観点チェックリスト（毎回確認）:**
- 矛盾・不整合はないか
- 暗黙の前提条件が崩れるケースはないか
- エッジケース・境界条件の漏れはないか
- 「正常系しか考えていない」箇所はないか
- 依存関係の見落としはないか
- 将来の変更で壊れやすい設計はないか

### DA品質フィルター（ノイズ削減）

DAレビューの精度を維持するため、以下のフィルターを適用する:

**1. 検証義務**: 指摘前にコード実行 or 仕様確認で事実を確認すること。
「〜かもしれない」だけの推測指摘は記録しない。
- ❌「この変数は falsy になる可能性がある」（未検証）
- ⭕「L42 で `parseInt(value)` に空文字を渡すと NaN になる。実際に input を空にして確認済み」

**2. 既知事項の除外**: 以下は指摘対象外とする。
- コード内の `TODO` / `FIXME` コメントで明示されている事項
- DD の「Phase X で対応」と記載されている事項
- 別 DD にスコープアウト済みの事項

**3. 深刻度の判定基準**:

| 深刻度 | 判定基準 | 例 |
|--------|---------|-----|
| 高 | 今のPhaseでテストが落ちる or ユーザー操作で壊れる | 関数の戻り値型が変わり呼び出し元でエラー |
| 中 | 特定条件下で壊れる（エッジケース・将来の変更時） | 空配列時にundefined参照、半年後のリファクタで破壊 |
| 低 | 壊れないが改善の余地がある | 命名の不統一、DRY違反、ドキュメント不足 |

**4. 再現手順の必須化**: 深刻度「高」「中」には以下を必ず記載:
- **操作**: 何をすると（例: servingsB に 0 を入力して送信）
- **結果**: 何が起きるか（例: cuisineBPanel が非表示にならない）

### 最低発見数ルール

| 変更規模 | 最低発見数 |
|---------|-----------|
| 小（1-2ファイル） | 1件以上 |
| 中（3-5ファイル） | 2件以上 |
| 大（6ファイル以上） | 3件以上 |

**発見数が最低ラインに満たない場合**: 変更ファイルを全行読み直してから再チェック

### 🔄 再チェック発動条件（どちらかを満たせば発動）

#### 条件A: 中レベル以上の発見がある場合（CRITICAL）

**重要度「中」または「高」が1件以上 → 🔄 別角度で再チェック必須**

- 中レベル以上 ＝ 設計判断の甘さや構造的な問題を示唆
- 同種の問題がまだ潜んでいる可能性が高い
- 「1件見つかったなら、似た問題がもう1件あるはず」の姿勢で探す

#### 条件B: 多数発見の場合

| 変更規模 | 発見数 | 追加アクション |
|---------|--------|--------------|
| 小（1-2ファイル） | 3件以上 | 🔄 別角度で再チェック必須 |
| 中（3-5ファイル） | 5件以上 | 🔄 別角度で再チェック必須 |
| 大（6ファイル以上） | 7件以上 | 🔄 別角度で再チェック必須 |

**🔄 別角度での再チェック方法:**

1. **視点を変える**: 実装者視点 → レビュアー視点 → ユーザー視点 → 将来の保守者視点
2. **チェック観点を変える**:
   - 1回目: 機能・ロジックの正しさ
   - 2回目: テストカバレッジ・境界値
   - 3回目: ドキュメント・仕様書との整合性
3. **関連ファイルを広げる**: 直接変更したファイル → importしているファイル → 同じディレクトリの関連ファイル

**記録例（中レベル発見 → 再チェック）:**
```markdown
### Phase N DA批判レビュー（2回目: 別角度チェック）

**発動理由:** 1回目で重要度「中」を2件発見
**切り替えた視点:** 実装者 → レビュアー（コードの一貫性・DRY原則）

**追加発見:**
| # | 発見した問題 | 視点 | 対応 |
|---|------------|------|------|
| 4 | 同じ定数が別ファイルにもある（DRY違反） | レビュアー | ⏭️別DD |
| 5 | READMEの使用例が古い | ユーザー | ✅修正済 |
```

### DA批判レビューチェックリスト（Phase種別ごと）

**【実装Phase】**
| チェック項目 | 具体的なアクション |
|-------------|-------------------|
| 関数網羅性 | 変更したファイルの全public関数をリストアップし、各関数がテストされているか確認 |
| 呼び出し元 | 変更した関数名でgrep。呼び出し元すべてに影響がないか確認 |
| エッジケース | null, 空配列, 0, 負値, 境界値を渡した場合の動作を確認 |
| 定数・マップ | 新規追加した定数/マップに漏れがないか（全パターン列挙して突合） |

**【テストPhase】**
| チェック項目 | 具体的なアクション |
|-------------|-------------------|
| 関数カバレッジ | 変更ファイルのexport一覧とテストファイルのdescribe一覧を突合 |
| 新規関数 | 今回追加した関数すべてにテストがあるか確認 |
| 異常系 | エラーケース・例外のテストを追加したか確認 |

**【ドキュメントPhase】**
| チェック項目 | 具体的なアクション |
|-------------|-------------------|
| 仕様書同期 | 変更したコードに対応する仕様書セクションを特定し、更新したか確認 |
| サンプル値 | ドキュメント内の例示値がコードと一致しているか確認 |

### 記録手順（必須: 発見形式）

**Step 1**: DDの「DA批判レビュー記録」セクションに**発見した問題**を記録

```markdown
### Phase N DA批判レビュー

**DA観点:** （このPhaseで最も壊れやすいポイントは何か？）

| # | 発見した問題/改善点 | 重要度 | 再現手順（高/中は必須） | DA観点 | 対応 |
|---|-------------------|--------|----------------------|--------|------|
| 1 | checker.test.jsにpasta/noodleテストがない | 高 | テスト実行→pastaケースが未検証 | エッジケース漏れ | ✅ 追加済 |
| 2 | validator.jsのパスタコード変更がpromptBuilder側に未反映 | 中 | パスタ選択→旧コードで生成 | 依存関係の見落とし | ✅ 修正済 |
| 3 | 仕様書11bの計算例が古い値のまま | 低 | - | 将来の保守性 | ⏭️ 別DD |

⚠️ 重要度「中」以上あり → 🔄 別角度で再チェック必須

**発見ゼロの場合（疑わしい）:**
以下を実施してから再チェック:
1. 変更ファイルを全行読み直す（Read tool使用）
2. 変更した関数名でgrepして呼び出し元を確認
3. テストカバレッジレポートを確認
```

**Step 2**: タスク一覧の「😈 DA批判レビュー」を完了に

**Step 3**: ログに完了を記録

### よくある見落としパターン

| パターン | 例 |
|---------|-----|
| テスト漏れ | 新規関数を追加したがテストを書いていない |
| 呼び出し元未確認 | 関数の戻り値を変更したが呼び出し元を確認していない |
| 定数マップ不完全 | 6種類あるはずが5種類しかマップに登録していない |
| 仕様書未更新 | コードは直したが仕様書に反映していない |
| export漏れ | 新関数を追加したがexportしていない（テスト不可） |

---

## GEM分析（最終Phase完了時）（CRITICAL）

**DDの最終Phaseが完了した後、Step 8（仕様書同期）の前に実行。**

各Phase完了時のDA批判レビューは同一コンテキスト内の自己チェックであり、楽観バイアスの影響を完全に排除できない。GEM分析はこの限界を補完するため、**独立した視点**からDD全体を批判的にレビューする。

### 実行タイミング

```
Step 7（レビュー）完了後 → ★ GEM分析 → Step 8（仕様書同期）
```

### 実行手順

#### 1. .env ファイルの確認

プロジェクトルートの `.env` ファイルを確認する:

```bash
cat .env 2>/dev/null | grep GEMINI_API_KEY
```

#### 2A. Gemini API による分析（GEMINI_API_KEY がある場合）

**2A-1. DD本文を取得**

対象DDファイルの全文を読み取る。

**2A-2. Gemini API を呼び出す**

```bash
# .env から設定を読み込む
source .env

# モデル名（デフォルト: gemini-2.5-flash）
MODEL="${GEMINI_MODEL:-gemini-2.5-flash}"

# DD本文を変数に格納（対象DDファイルのパスを指定）
DD_CONTENT=$(cat "{DDファイルパス}")

# レビュープロンプトを構築（REVIEW_PROMPT は下記「レビュープロンプト」参照）
PROMPT="${REVIEW_PROMPT}

---

## DD本文

${DD_CONTENT}"

# Gemini API 呼び出し
RESPONSE=$(curl -s "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent" \
  -H "x-goog-api-key: ${GEMINI_API_KEY}" \
  -H 'Content-Type: application/json' \
  -X POST \
  -d "$(jq -n --arg text "$PROMPT" '{contents: [{parts: [{text: $text}]}]}')")

# レスポンスからテキストを抽出
RESULT=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // "エラー: レスポンスの解析に失敗"')

# エラーチェック — エラー時は手順2Bへフォールバック
if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
  ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error.message')
  echo "Gemini API エラー: $ERROR_MSG"
  echo "→ フォールバック: 別コンテキストDA分析を実行します"
fi
```

**2A-3. 結果をDDに記録**

`$RESULT` の内容をDDの「GEM分析結果」セクションに記録する:
- 「分析方式」に `Gemini API ({MODEL名})` と記載
- 指摘事項テーブルと総合評価を転記
- 各指摘に対する「対応」列を追加して、対応方針を記入

#### 2B. 別コンテキストDA分析（GEMINI_API_KEY がない場合 / APIエラー時のフォールバック）

**目的**: 会話コンテキストの汚染を排除するため、DD文書のみを渡した別コンテキストで批判的レビューを実施する。

**2B-1. Task agentを使用して別コンテキストでDA分析を実行**

Task agentにDD文書の内容のみを渡し、下記「レビュープロンプト」で分析を依頼する。

**重要**: Task agentには **DD文書の内容のみ** を渡す。会話履歴、実装コンテキスト、これまでの議論は一切渡さない。これにより、同一コンテキストのバイアスを排除する。

**2B-2. 結果をDDに記録**

Task agentの出力をDDの「GEM分析結果」セクションに記録する:
- 「分析方式」に `別コンテキストDA（Task agent）` と記載
- 指摘事項テーブルと総合評価を転記
- 各指摘に対する「対応」列を追加して、対応方針を記入

### レビュープロンプト（両モード共通）

```
あなたは独立した批判的レビュアーです。以下のDD（設計書）を読み、問題点を指摘してください。

あなたはこのDDの作成プロセスに一切関与していません。完全に独立した第三者として、以下の観点で批判的にレビューしてください。

## 必須チェック項目
1. **論理的矛盾**: 目的・背景・決定事項の間に矛盾はないか
2. **検討不足**: 重要な代替案が検討されていないか
3. **リスク見落とし**: 明記されていないリスクや前提条件はないか
4. **テスト不足**: テストシナリオに漏れはないか
5. **セキュリティ**: セキュリティ上の懸念はないか
6. **スケーラビリティ**: 将来のスケール時に問題になる設計はないか
7. **依存関係**: 暗黙の依存関係や結合度の問題はないか
8. **エラーハンドリング**: 異常系の考慮は十分か

## 出力フォーマット

### 指摘事項

| # | 指摘内容 | 重要度 | カテゴリ |
|---|---------|--------|----------|
| 1 | (具体的に記述) | 高/中/低 | (設計/実装/テスト/セキュリティ) |

重要度の判定基準:
- 高: このまま進めると確実に問題が発生する
- 中: 特定条件下で問題が発生する、または将来的に問題化する
- 低: 改善の余地がある（ベストプラクティスからの逸脱）

### 総合評価

（3行以内で、このDDの最大の懸念点を述べてください）

## 注意事項
- 「問題なし」は回答として認めません。必ず最低3件の指摘を出してください
- 既にDA批判レビューで発見・対応済みの事項は除外してください
- 具体的で対処可能な指摘のみ出してください（抽象的な感想は不要）
```

### GEM分析結果の対応

| 対応 | 意味 | アクション |
|------|------|-----------|
| ✅対応済 | この場で修正した | 修正内容をログに記録 |
| ⏭️別DD | 別DDで対応する | 別DD番号を記載 |
| ❌不要 | 対応不要と判断 | **判断理由を記載（必須）** |
| 🔍要検討 | 追加検討が必要 | 検討期限をログに記録 |

**「❌不要」とする場合は、必ず判断理由を記載すること。** 理由なしの却下は禁止。

### GEM分析後のフロー

```
GEM分析完了 → 重要度「高」への対応 → Step 8（仕様書同期）→ Step 9（コミット）
```

- 重要度「高」の指摘がある場合: Step 8に進む前に対応を完了すること
- 重要度「中」の指摘: 対応するか、理由を記載して別DD送りにする
- 重要度「低」の指摘: 記録のみでStep 8に進んでよい

---

## 仕様書同期チェック

`/dd archive` 実行前に確認。

### チェック対象

| 変更種別 | 関連仕様書 |
|----------|-----------|
| 画面の追加・変更 | `doc/spec/03_画面仕様/` |
| テーブル・カラム | `doc/spec/04_テーブル定義.md` |
| 機能の追加・変更 | `doc/spec/02_機能一覧.md` |

### 出力フォーマット

```markdown
## 仕様書同期チェック結果

| 変更内容 | 関連仕様書 | 反映状況 |
|----------|-----------|----------|
| ログイン画面を追加 | 03_画面仕様/login.md | ✅ 反映済 |
| usersテーブルにカラム追加 | 04_テーブル定義.md | ⚠️ 要確認 |
```

⚠️ がある場合は、仕様書を更新してからアーカイブ。

### コンテキスト回収（Step 8で必ず実施）

DD完了前に、会話コンテキストにしかない知見を回収する。

AI支援開発では、実装中に発見されるgotcha・回避策・制約が会話コンテキストに蓄積される。これをDD本体に書き戻さないと：
- **知見が揮発する** — セッション終了とともに失われる
- **AI記憶が肥大化する** — DDに属する詳細がMEMORY.md等に書かれ、容量を圧迫する
- **後から参照できない** — 完了済みDDを見ても「なぜこうしたか」が分からない

| # | 確認項目 |
|---|---------|
| 1 | 実装中の発見（gotcha・回避策・制約）をDD本体に書き戻したか |
| 2 | AI記憶（MEMORY.md等）から該当DD固有の詳細エントリを削除したか |
| 3 | 横断知見（環境のハマりポイント等、他DDでも再発しうるもの）だけ記憶に残したか |

**判断基準:**

| 情報の種類 | 置き場所 | 例 |
|-----------|---------|-----|
| DD固有の実装詳細 | DD本体 | 「AuthStateにfirebaseUid追加が必要」 |
| 機能固有の仕様 | 該当仕様書 | 「color-mix()でhover色を算出」 |
| 横断的な環境のハマりポイント | AI記憶 | 「vitest 4.x + jsdomは --pool=forks で回避」 |
| プロジェクト構成の概要 | AI記憶 | 「tools/menu-engine/ は ESM」 |

---

## 関連

- `/dd` - DD操作（作成、参照、一覧、アーカイブ）
- `doc/development-flow-full.md` - フロー詳細
